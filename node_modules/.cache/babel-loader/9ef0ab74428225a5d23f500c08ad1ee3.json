{"ast":null,"code":"import _toConsumableArray from \"E:\\\\School Web Application\\\\FrontEnd\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport { isLeaf } from '../../../models/gridColumnGrouping';\nimport { isDeepEqual } from '../../../utils/utils';\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nvar recurrentUnwrapGroupingColumnModel = function recurrentUnwrapGroupingColumnModel(columnGroupNode, parents, unwrappedGroupingModelToComplete) {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([\"MUI: columnGroupingModel contains duplicated field\", \"column field \".concat(columnGroupNode.field, \" occurs two times in the grouping model:\"), \"- \".concat(unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')), \"- \".concat(parents.join(' > '))].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  var groupId = columnGroupNode.groupId,\n    children = columnGroupNode.children;\n  children.forEach(function (child) {\n    recurrentUnwrapGroupingColumnModel(child, [].concat(_toConsumableArray(parents), [groupId]), unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport var unwrapGroupingColumnModel = function unwrapGroupingColumnModel(columnGroupingModel) {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  var unwrappedSubTree = {};\n  columnGroupingModel.forEach(function (columnGroupNode) {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport var getColumnGroupsHeaderStructure = function getColumnGroupsHeaderStructure(orderedColumns, unwrappedGroupingModel) {\n  var getParents = function getParents(field) {\n    var _unwrappedGroupingMod;\n    return (_unwrappedGroupingMod = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod : [];\n  };\n  var groupingHeaderStructure = [];\n  var maxDepth = Math.max.apply(Math, _toConsumableArray(orderedColumns.map(function (field) {\n    return getParents(field).length;\n  })));\n  var haveSameParents = function haveSameParents(field1, field2, depth) {\n    return isDeepEqual(getParents(field1).slice(0, depth + 1), getParents(field2).slice(0, depth + 1));\n  };\n  var _loop = function _loop(depth) {\n    var depthStructure = orderedColumns.reduce(function (structure, newField) {\n      var _getParents$depth;\n      var groupId = (_getParents$depth = getParents(newField)[depth]) != null ? _getParents$depth : null;\n      if (structure.length === 0) {\n        return [{\n          columnFields: [newField],\n          groupId: groupId\n        }];\n      }\n      var lastGroup = structure[structure.length - 1];\n      var prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      var prevGroupId = lastGroup.groupId;\n      if (prevGroupId !== groupId || !haveSameParents(prevField, newField, depth)) {\n        // It's a new group\n        return [].concat(_toConsumableArray(structure), [{\n          columnFields: [newField],\n          groupId: groupId\n        }]);\n      }\n\n      // It extends the previous group\n      return [].concat(_toConsumableArray(structure.slice(0, structure.length - 1)), [{\n        columnFields: [].concat(_toConsumableArray(lastGroup.columnFields), [newField]),\n        groupId: groupId\n      }]);\n    }, []);\n    groupingHeaderStructure.push(depthStructure);\n  };\n  for (var depth = 0; depth < maxDepth; depth += 1) {\n    _loop(depth);\n  }\n  return groupingHeaderStructure;\n};","map":null,"metadata":{},"sourceType":"module"}
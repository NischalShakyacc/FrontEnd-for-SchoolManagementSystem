{"ast":null,"code":"import _slicedToArray from \"E:\\\\React\\\\final\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_debounce as debounce, unstable_capitalize as capitalize } from '@mui/utils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nimport { gridFilterModelSelector } from '../filter/gridFilterSelector';\nimport { gridPaginationSelector } from '../pagination/gridPaginationSelector';\nimport { gridSortModelSelector } from '../sorting/gridSortingSelector';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { DATA_GRID_PROPS_DEFAULT_VALUES } from '../../../DataGrid/useDataGridProps';\nexport var rowsMetaStateInitializer = function rowsMetaStateInitializer(state) {\n  return _extends({}, state, {\n    rowsMeta: {\n      currentPageTotalHeight: 0,\n      positions: []\n    }\n  });\n};\nvar warnedOnceInvalidRowHeight = false;\nvar getValidRowHeight = function getValidRowHeight(rowHeightProp, defaultRowHeight, warningMessage) {\n  if (typeof rowHeightProp === 'number' && rowHeightProp > 0) {\n    return rowHeightProp;\n  }\n  if (process.env.NODE_ENV !== 'production' && !warnedOnceInvalidRowHeight && typeof rowHeightProp !== 'undefined' && rowHeightProp !== null) {\n    console.warn(warningMessage);\n    warnedOnceInvalidRowHeight = true;\n  }\n  return defaultRowHeight;\n};\nvar rowHeightWarning = [\"MUI: The `rowHeight` prop should be a number greater than 0.\", \"The default value will be used instead.\"].join('\\n');\nvar getRowHeightWarning = [\"MUI: The `getRowHeight` prop should return a number greater than 0 or 'auto'.\", \"The default value will be used instead.\"].join('\\n');\n\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\nexport var useGridRowsMeta = function useGridRowsMeta(apiRef, props) {\n  var getRowHeightProp = props.getRowHeight,\n    getRowSpacing = props.getRowSpacing,\n    getEstimatedRowHeight = props.getEstimatedRowHeight;\n  var rowsHeightLookup = React.useRef({});\n\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  var lastMeasuredRowIndex = React.useRef(-1);\n  var hasRowWithAutoHeight = React.useRef(false);\n  var densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);\n  var filterModel = useGridSelector(apiRef, gridFilterModelSelector);\n  var paginationState = useGridSelector(apiRef, gridPaginationSelector);\n  var sortModel = useGridSelector(apiRef, gridSortModelSelector);\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  var validRowHeight = getValidRowHeight(props.rowHeight, DATA_GRID_PROPS_DEFAULT_VALUES.rowHeight, rowHeightWarning);\n  var rowHeight = Math.floor(validRowHeight * densityFactor);\n  var hydrateRowsMeta = React.useCallback(function () {\n    var _pinnedRows$top, _pinnedRows$bottom;\n    hasRowWithAutoHeight.current = false;\n    var calculateRowProcessedSizes = function calculateRowProcessedSizes(row) {\n      if (!rowsHeightLookup.current[row.id]) {\n        rowsHeightLookup.current[row.id] = {\n          sizes: {\n            baseCenter: rowHeight\n          },\n          isResized: false,\n          autoHeight: false,\n          needsFirstMeasurement: true // Assume all rows will need to be measured by default\n        };\n      }\n      var _rowsHeightLookup$cur3 = rowsHeightLookup.current[row.id],\n        isResized = _rowsHeightLookup$cur3.isResized,\n        needsFirstMeasurement = _rowsHeightLookup$cur3.needsFirstMeasurement,\n        sizes = _rowsHeightLookup$cur3.sizes;\n      var baseRowHeight = typeof rowHeight === 'number' && rowHeight > 0 ? rowHeight : 52;\n      var existingBaseRowHeight = sizes.baseCenter;\n      if (isResized) {\n        // Do not recalculate resized row height and use the value from the lookup\n        baseRowHeight = existingBaseRowHeight;\n      } else if (getRowHeightProp) {\n        var rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n          densityFactor: densityFactor\n        }));\n        if (rowHeightFromUser === 'auto') {\n          if (needsFirstMeasurement) {\n            var estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n              densityFactor: densityFactor\n            })) : rowHeight;\n\n            // If the row was not measured yet use the estimated row height\n            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeight;\n          } else {\n            baseRowHeight = existingBaseRowHeight;\n          }\n          hasRowWithAutoHeight.current = true;\n          rowsHeightLookup.current[row.id].autoHeight = true;\n        } else {\n          // Default back to base rowHeight if getRowHeight returns invalid value.\n          baseRowHeight = getValidRowHeight(rowHeightFromUser, rowHeight, getRowHeightWarning);\n          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n          rowsHeightLookup.current[row.id].autoHeight = false;\n        }\n      } else {\n        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;\n      }\n      var existingBaseSizes = Object.entries(sizes).reduce(function (acc, _ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          size = _ref2[1];\n        if (/^base[A-Z]/.test(key)) {\n          acc[key] = size;\n        }\n        return acc;\n      }, {});\n\n      // We use an object to make simple to check if a height is already added or not\n      var initialHeights = _extends({}, existingBaseSizes, {\n        baseCenter: baseRowHeight\n      });\n      if (getRowSpacing) {\n        var _spacing$top, _spacing$bottom;\n        var indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n        var spacing = getRowSpacing(_extends({}, row, {\n          isFirstVisible: indexRelativeToCurrentPage === 0,\n          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n          indexRelativeToCurrentPage: indexRelativeToCurrentPage\n        }));\n        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;\n        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;\n      }\n      var processedSizes = apiRef.current.unstable_applyPipeProcessors('rowHeight', initialHeights, row);\n      rowsHeightLookup.current[row.id].sizes = processedSizes;\n      return processedSizes;\n    };\n    var positions = [];\n    var currentPageTotalHeight = currentPage.rows.reduce(function (acc, row) {\n      positions.push(acc);\n      var maximumBaseSize = 0;\n      var otherSizes = 0;\n      var processedSizes = calculateRowProcessedSizes(row);\n      Object.entries(processedSizes).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          size = _ref4[0],\n          value = _ref4[1];\n        if (/^base[A-Z]/.test(size)) {\n          maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;\n        } else {\n          otherSizes += value;\n        }\n      });\n      return acc + maximumBaseSize + otherSizes;\n    }, 0);\n    pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.forEach(function (row) {\n      calculateRowProcessedSizes(row);\n    });\n    pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.forEach(function (row) {\n      calculateRowProcessedSizes(row);\n    });\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rowsMeta: {\n          currentPageTotalHeight: currentPageTotalHeight,\n          positions: positions\n        }\n      });\n    });\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n    apiRef.current.forceUpdate();\n  }, [apiRef, currentPage.rows, rowHeight, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows, densityFactor]);\n  var getRowHeight = React.useCallback(function (rowId) {\n    var height = rowsHeightLookup.current[rowId];\n    return height ? height.sizes.baseCenter : rowHeight;\n  }, [rowHeight]);\n  var getRowInternalSizes = function getRowInternalSizes(rowId) {\n    var _rowsHeightLookup$cur;\n    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;\n  };\n  var setRowHeight = React.useCallback(function (id, height) {\n    rowsHeightLookup.current[id].sizes.baseCenter = height;\n    rowsHeightLookup.current[id].isResized = true;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  var debouncedHydrateRowsMeta = React.useMemo(function () {\n    return debounce(hydrateRowsMeta);\n  }, [hydrateRowsMeta]);\n  var storeMeasuredRowHeight = React.useCallback(function (id, height, position) {\n    if (!rowsHeightLookup.current[id] || !rowsHeightLookup.current[id].autoHeight) {\n      return;\n    }\n\n    // Only trigger hydration if the value is different, otherwise we trigger a loop\n    var needsHydration = rowsHeightLookup.current[id].sizes[\"base\".concat(capitalize(position))] !== height;\n    rowsHeightLookup.current[id].needsFirstMeasurement = false;\n    rowsHeightLookup.current[id].sizes[\"base\".concat(capitalize(position))] = height;\n    if (needsHydration) {\n      debouncedHydrateRowsMeta();\n    }\n  }, [debouncedHydrateRowsMeta]);\n  var rowHasAutoHeight = React.useCallback(function (id) {\n    var _rowsHeightLookup$cur2;\n    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;\n  }, []);\n  var getLastMeasuredRowIndex = React.useCallback(function () {\n    return lastMeasuredRowIndex.current;\n  }, []);\n  var setLastMeasuredRowIndex = React.useCallback(function (index) {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  }, []);\n  var resetRowHeights = React.useCallback(function () {\n    rowsHeightLookup.current = {};\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n\n  // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n  React.useEffect(function () {\n    hydrateRowsMeta();\n  }, [rowHeight, filterModel, paginationState, sortModel, hydrateRowsMeta]);\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n  var rowsMetaApi = {\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_getRowHeight: getRowHeight,\n    unstable_getRowInternalSizes: getRowInternalSizes,\n    unstable_setRowHeight: setRowHeight,\n    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,\n    resetRowHeights: resetRowHeights\n  };\n  var rowsMetaPrivateApi = {\n    getLastMeasuredRowIndex: getLastMeasuredRowIndex,\n    rowHasAutoHeight: rowHasAutoHeight\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'public');\n  useGridApiMethod(apiRef, rowsMetaPrivateApi, 'private');\n};","map":null,"metadata":{},"sourceType":"module"}
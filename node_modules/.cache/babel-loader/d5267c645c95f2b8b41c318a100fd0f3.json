{"ast":null,"code":"import _toConsumableArray from \"E:\\\\School Web Application\\\\FrontEnd\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDensityFactorSelector } from '../density/densitySelector';\nexport var GRID_ROOT_GROUP_ID = \"auto-generated-group-node-root\";\nexport var buildRootGroup = function buildRootGroup() {\n  return {\n    type: 'group',\n    id: GRID_ROOT_GROUP_ID,\n    depth: -1,\n    groupingField: null,\n    groupingKey: null,\n    isAutoGenerated: true,\n    children: [],\n    childrenFromPath: {},\n    childrenExpanded: true,\n    parent: null\n  };\n};\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexport function checkGridRowIdIsValid(id, row) {\n  var detailErrorMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'A row was provided without id in the rows prop:';\n  if (id == null) {\n    throw new Error(['MUI: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport var getRowIdFromRowModel = function getRowIdFromRowModel(rowModel, getRowId, detailErrorMessage) {\n  var id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport var createRowsInternalCache = function createRowsInternalCache(_ref) {\n  var rows = _ref.rows,\n    getRowId = _ref.getRowId,\n    loading = _ref.loading,\n    rowCount = _ref.rowCount;\n  var updates = {\n    type: 'full',\n    rows: []\n  };\n  var dataRowIdToModelLookup = {};\n  var dataRowIdToIdLookup = {};\n  for (var i = 0; i < rows.length; i += 1) {\n    var model = rows[i];\n    var id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates: updates,\n    dataRowIdToIdLookup: dataRowIdToIdLookup,\n    dataRowIdToModelLookup: dataRowIdToModelLookup\n  };\n};\nexport var getTopLevelRowCount = function getTopLevelRowCount(_ref2) {\n  var tree = _ref2.tree,\n    _ref2$rowCountProp = _ref2.rowCountProp,\n    rowCountProp = _ref2$rowCountProp === void 0 ? 0 : _ref2$rowCountProp;\n  var rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport var getRowsStateFromCache = function getRowsStateFromCache(_ref3) {\n  var apiRef = _ref3.apiRef,\n    _ref3$rowCountProp = _ref3.rowCountProp,\n    rowCountProp = _ref3$rowCountProp === void 0 ? 0 : _ref3$rowCountProp,\n    loadingProp = _ref3.loadingProp,\n    previousTree = _ref3.previousTree,\n    previousTreeDepths = _ref3.previousTreeDepths;\n  var cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  var _apiRef$current$apply = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n      previousTree: previousTree,\n      previousTreeDepths: previousTreeDepths,\n      updates: cache.updates,\n      dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n      dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n    }),\n    unProcessedTree = _apiRef$current$apply.tree,\n    unProcessedTreeDepths = _apiRef$current$apply.treeDepths,\n    unProcessedDataRowIds = _apiRef$current$apply.dataRowIds,\n    groupingName = _apiRef$current$apply.groupingName; // 2. Apply the \"hydrateRows\" pipe-processing.\n  var groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp: rowCountProp\n    }),\n    groupingName: groupingName,\n    loading: loadingProp\n  });\n};\nexport var isAutoGeneratedRow = function isAutoGeneratedRow(rowNode) {\n  return rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\n};\nexport var getTreeNodeDescendants = function getTreeNodeDescendants(tree, parentId, skipAutoGeneratedRows) {\n  var node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  var validDescendants = [];\n  for (var i = 0; i < node.children.length; i += 1) {\n    var child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n    validDescendants.push.apply(validDescendants, _toConsumableArray(getTreeNodeDescendants(tree, child, skipAutoGeneratedRows)));\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexport var updateCacheWithNewRows = function updateCacheWithNewRows(_ref4) {\n  var previousCache = _ref4.previousCache,\n    getRowId = _ref4.getRowId,\n    updates = _ref4.updates;\n  var _previousCache$update, _previousCache$update2, _previousCache$update3;\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI: Unable to prepare a partial update if a full update is not applied yet');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  var uniqueUpdates = new Map();\n  updates.forEach(function (update) {\n    var id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  var partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: _toConsumableArray((_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : []),\n      modify: _toConsumableArray((_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : []),\n      remove: _toConsumableArray((_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : [])\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n  var dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n  var dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n  var alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach(function (partialRow, id) {\n    var actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n    var oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  var actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  var _loop = function _loop() {\n    var actionType = actionTypeWithActionsToRemove[i];\n    var idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(function (id) {\n        return !idsToRemove[id];\n      });\n    }\n  };\n  for (var i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    _loop();\n  }\n  return {\n    dataRowIdToModelLookup: dataRowIdToModelLookup,\n    dataRowIdToIdLookup: dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  var _pinnedRows$top, _pinnedRows$bottom;\n  var pinnedRows = gridPinnedRowsSelector(apiRef);\n  var topPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce(function (acc, value) {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  var bottomPinnedRowsHeight = (pinnedRows == null ? void 0 : (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce(function (acc, value) {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0)) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef, rowHeight) {\n  var densityFactor = gridDensityFactorSelector(apiRef);\n  return 2 * Math.floor(rowHeight * densityFactor);\n}","map":null,"metadata":{},"sourceType":"module"}
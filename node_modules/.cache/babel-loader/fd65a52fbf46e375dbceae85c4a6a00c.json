{"ast":null,"code":"import _toConsumableArray from \"E:\\\\React\\\\final\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"E:\\\\React\\\\final\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnFieldsSelector, gridColumnDefinitionsSelector, gridColumnLookupSelector, gridColumnsStateSelector, gridColumnVisibilityModelSelector, gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from './gridColumnsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridRegisterPipeProcessor, useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nimport { hydrateColumnsWidth, createColumnsState, mergeColumnsState, COLUMNS_DIMENSION_PROPERTIES } from './gridColumnsUtils';\nimport { GridPreferencePanelsValue } from '../preferencesPanel';\nimport { getGridDefaultColumnTypes } from '../../../colDef';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar defaultColumnTypes = getGridDefaultColumnTypes();\nexport var columnsStateInitializer = function columnsStateInitializer(state, props, apiRef) {\n  var _props$initialState, _ref, _props$columnVisibili, _props$initialState2, _props$initialState2$;\n  var columnsState = createColumnsState({\n    apiRef: apiRef,\n    columnTypes: defaultColumnTypes,\n    columnsToUpsert: props.columns,\n    initialState: (_props$initialState = props.initialState) == null ? void 0 : _props$initialState.columns,\n    columnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.columns) == null ? void 0 : _props$initialState2$.columnVisibilityModel) != null ? _ref : {},\n    keepOnlyColumnsToUpsert: true\n  });\n  return _extends({}, state, {\n    columns: columnsState\n  });\n};\n\n/**\n * @requires useGridParamsApi (method)\n * @requires useGridDimensions (method, event) - can be after\n * TODO: Impossible priority - useGridParamsApi also needs to be after useGridColumns\n */\nexport function useGridColumns(apiRef, props) {\n  var _props$initialState4, _props$slotProps2;\n  var logger = useGridLogger(apiRef, 'useGridColumns');\n  var columnTypes = defaultColumnTypes;\n  var previousColumnsProp = React.useRef(props.columns);\n  var previousColumnTypesProp = React.useRef(columnTypes);\n  apiRef.current.registerControlState({\n    stateId: 'visibleColumns',\n    propModel: props.columnVisibilityModel,\n    propOnChange: props.onColumnVisibilityModelChange,\n    stateSelector: gridColumnVisibilityModelSelector,\n    changeEvent: 'columnVisibilityModelChange'\n  });\n  var setGridColumnsState = React.useCallback(function (columnsState) {\n    logger.debug('Updating columns state.');\n    apiRef.current.setState(mergeColumnsState(columnsState));\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('columnsChange', columnsState.orderedFields);\n  }, [logger, apiRef]);\n\n  /**\n   * API METHODS\n   */\n  var getColumn = React.useCallback(function (field) {\n    return gridColumnLookupSelector(apiRef)[field];\n  }, [apiRef]);\n  var getAllColumns = React.useCallback(function () {\n    return gridColumnDefinitionsSelector(apiRef);\n  }, [apiRef]);\n  var getVisibleColumns = React.useCallback(function () {\n    return gridVisibleColumnDefinitionsSelector(apiRef);\n  }, [apiRef]);\n  var getColumnIndex = React.useCallback(function (field) {\n    var useVisibleColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);\n    return columns.findIndex(function (col) {\n      return col.field === field;\n    });\n  }, [apiRef]);\n  var getColumnPosition = React.useCallback(function (field) {\n    var index = getColumnIndex(field);\n    return gridColumnPositionsSelector(apiRef)[index];\n  }, [apiRef, getColumnIndex]);\n  var setColumnVisibilityModel = React.useCallback(function (model) {\n    var currentModel = gridColumnVisibilityModelSelector(apiRef);\n    if (currentModel !== model) {\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          columns: createColumnsState({\n            apiRef: apiRef,\n            columnTypes: columnTypes,\n            columnsToUpsert: [],\n            initialState: undefined,\n            columnVisibilityModel: model,\n            keepOnlyColumnsToUpsert: false\n          })\n        });\n      });\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, columnTypes]);\n  var updateColumns = React.useCallback(function (columns) {\n    var columnsState = createColumnsState({\n      apiRef: apiRef,\n      columnTypes: columnTypes,\n      columnsToUpsert: columns,\n      initialState: undefined,\n      keepOnlyColumnsToUpsert: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, setGridColumnsState, columnTypes]);\n  var setColumnVisibility = React.useCallback(function (field, isVisible) {\n    var _columnVisibilityMode;\n    var columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);\n    var isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;\n    if (isVisible !== isCurrentlyVisible) {\n      var newModel = _extends({}, columnVisibilityModel, _defineProperty({}, field, isVisible));\n      apiRef.current.setColumnVisibilityModel(newModel);\n    }\n  }, [apiRef]);\n  var getColumnIndexRelativeToVisibleColumns = React.useCallback(function (field) {\n    var allColumns = gridColumnFieldsSelector(apiRef);\n    return allColumns.findIndex(function (col) {\n      return col === field;\n    });\n  }, [apiRef]);\n  var setColumnIndex = React.useCallback(function (field, targetIndexPosition) {\n    var allColumns = gridColumnFieldsSelector(apiRef);\n    var oldIndexPosition = getColumnIndexRelativeToVisibleColumns(field);\n    if (oldIndexPosition === targetIndexPosition) {\n      return;\n    }\n    logger.debug(\"Moving column \".concat(field, \" to index \").concat(targetIndexPosition));\n    var updatedColumns = _toConsumableArray(allColumns);\n    var fieldRemoved = updatedColumns.splice(oldIndexPosition, 1)[0];\n    updatedColumns.splice(targetIndexPosition, 0, fieldRemoved);\n    setGridColumnsState(_extends({}, gridColumnsStateSelector(apiRef.current.state), {\n      orderedFields: updatedColumns\n    }));\n    var params = {\n      column: apiRef.current.getColumn(field),\n      targetIndex: apiRef.current.getColumnIndexRelativeToVisibleColumns(field),\n      oldIndex: oldIndexPosition\n    };\n    apiRef.current.publishEvent('columnIndexChange', params);\n  }, [apiRef, logger, setGridColumnsState, getColumnIndexRelativeToVisibleColumns]);\n  var setColumnWidth = React.useCallback(function (field, width) {\n    logger.debug(\"Updating column \".concat(field, \" width to \").concat(width));\n    var column = apiRef.current.getColumn(field);\n    var newColumn = _extends({}, column, {\n      width: width\n    });\n    apiRef.current.updateColumns([newColumn]);\n    apiRef.current.publishEvent('columnWidthChange', {\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: newColumn,\n      width: width\n    });\n  }, [apiRef, logger]);\n  var columnApi = {\n    getColumn: getColumn,\n    getAllColumns: getAllColumns,\n    getColumnIndex: getColumnIndex,\n    getColumnPosition: getColumnPosition,\n    getVisibleColumns: getVisibleColumns,\n    getColumnIndexRelativeToVisibleColumns: getColumnIndexRelativeToVisibleColumns,\n    updateColumns: updateColumns,\n    setColumnVisibilityModel: setColumnVisibilityModel,\n    setColumnVisibility: setColumnVisibility,\n    setColumnWidth: setColumnWidth\n  };\n  var columnReorderApi = {\n    setColumnIndex: setColumnIndex\n  };\n  useGridApiMethod(apiRef, columnApi, 'public');\n  useGridApiMethod(apiRef, columnReorderApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n\n  /**\n   * PRE-PROCESSING\n   */\n  var stateExportPreProcessing = React.useCallback(function (prevState, context) {\n    var _props$initialState$c, _props$initialState3, _props$initialState3$;\n    var columnsStateToExport = {};\n    var columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);\n    var shouldExportColumnVisibilityModel =\n    // Always export if the `exportOnlyDirtyModels` property is not activated\n    !context.exportOnlyDirtyModels ||\n    // Always export if the model is controlled\n    props.columnVisibilityModel != null ||\n    // Always export if the model has been initialized\n    // TODO v6 Do a nullish check instead to export even if the initial model equals \"{}\"\n    Object.keys((_props$initialState$c = (_props$initialState3 = props.initialState) == null ? void 0 : (_props$initialState3$ = _props$initialState3.columns) == null ? void 0 : _props$initialState3$.columnVisibilityModel) != null ? _props$initialState$c : {}).length > 0 ||\n    // Always export if the model is not empty\n    Object.keys(columnVisibilityModelToExport).length > 0;\n    if (shouldExportColumnVisibilityModel) {\n      columnsStateToExport.columnVisibilityModel = columnVisibilityModelToExport;\n    }\n    columnsStateToExport.orderedFields = gridColumnFieldsSelector(apiRef);\n    var columns = gridColumnDefinitionsSelector(apiRef);\n    var dimensions = {};\n    columns.forEach(function (colDef) {\n      if (colDef.hasBeenResized) {\n        var colDefDimensions = {};\n        COLUMNS_DIMENSION_PROPERTIES.forEach(function (propertyName) {\n          var propertyValue = colDef[propertyName];\n          if (propertyValue === Infinity) {\n            propertyValue = -1;\n          }\n          colDefDimensions[propertyName] = propertyValue;\n        });\n        dimensions[colDef.field] = colDefDimensions;\n      }\n    });\n    if (Object.keys(dimensions).length > 0) {\n      columnsStateToExport.dimensions = dimensions;\n    }\n    return _extends({}, prevState, {\n      columns: columnsStateToExport\n    });\n  }, [apiRef, props.columnVisibilityModel, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.columns]);\n  var stateRestorePreProcessing = React.useCallback(function (params, context) {\n    var _context$stateToResto;\n    var columnVisibilityModelToImport = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;\n    var initialState = context.stateToRestore.columns;\n    if (columnVisibilityModelToImport == null && initialState == null) {\n      return params;\n    }\n    var columnsState = createColumnsState({\n      apiRef: apiRef,\n      columnTypes: columnTypes,\n      columnsToUpsert: [],\n      initialState: initialState,\n      columnVisibilityModel: columnVisibilityModelToImport,\n      keepOnlyColumnsToUpsert: false\n    });\n    apiRef.current.setState(mergeColumnsState(columnsState));\n    if (initialState != null) {\n      apiRef.current.publishEvent('columnsChange', columnsState.orderedFields);\n    }\n    return params;\n  }, [apiRef, columnTypes]);\n  var preferencePanelPreProcessing = React.useCallback(function (initialValue, value) {\n    if (value === GridPreferencePanelsValue.columns) {\n      var _props$slotProps;\n      var ColumnsPanel = props.slots.columnsPanel;\n      return /*#__PURE__*/_jsx(ColumnsPanel, _extends({}, (_props$slotProps = props.slotProps) == null ? void 0 : _props$slotProps.columnsPanel));\n    }\n    return initialValue;\n  }, [props.slots.columnsPanel, (_props$slotProps2 = props.slotProps) == null ? void 0 : _props$slotProps2.columnsPanel]);\n  var addColumnMenuItems = React.useCallback(function (columnMenuItems) {\n    if (props.disableColumnSelector) {\n      return columnMenuItems;\n    }\n    return [].concat(_toConsumableArray(columnMenuItems), ['columnMenuColumnsItem']);\n  }, [props.disableColumnSelector]);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuItems);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'preferencePanel', preferencePanelPreProcessing);\n\n  /**\n   * EVENTS\n   */\n  var prevInnerWidth = React.useRef(null);\n  var handleGridSizeChange = function handleGridSizeChange(viewportInnerSize) {\n    if (prevInnerWidth.current !== viewportInnerSize.width) {\n      prevInnerWidth.current = viewportInnerSize.width;\n      setGridColumnsState(hydrateColumnsWidth(gridColumnsStateSelector(apiRef.current.state), viewportInnerSize.width));\n    }\n  };\n  useGridApiEventHandler(apiRef, 'viewportInnerSizeChange', handleGridSizeChange);\n\n  /**\n   * APPLIERS\n   */\n  var hydrateColumns = React.useCallback(function () {\n    logger.info(\"Columns pipe processing have changed, regenerating the columns\");\n    var columnsState = createColumnsState({\n      apiRef: apiRef,\n      columnTypes: columnTypes,\n      columnsToUpsert: [],\n      initialState: undefined,\n      keepOnlyColumnsToUpsert: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, logger, setGridColumnsState, columnTypes]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateColumns', hydrateColumns);\n\n  /**\n   * EFFECTS\n   */\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    logger.info(\"GridColumns have changed, new length \".concat(props.columns.length));\n    if (previousColumnsProp.current === props.columns && previousColumnTypesProp.current === columnTypes) {\n      return;\n    }\n    var columnsState = createColumnsState({\n      apiRef: apiRef,\n      columnTypes: columnTypes,\n      initialState: undefined,\n      // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`\n      columnsToUpsert: props.columns,\n      keepOnlyColumnsToUpsert: true\n    });\n    previousColumnsProp.current = props.columns;\n    previousColumnTypesProp.current = columnTypes;\n    setGridColumnsState(columnsState);\n  }, [logger, apiRef, setGridColumnsState, props.columns, columnTypes]);\n  React.useEffect(function () {\n    if (props.columnVisibilityModel !== undefined) {\n      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);\n    }\n  }, [apiRef, logger, props.columnVisibilityModel]);\n}","map":null,"metadata":{},"sourceType":"module"}
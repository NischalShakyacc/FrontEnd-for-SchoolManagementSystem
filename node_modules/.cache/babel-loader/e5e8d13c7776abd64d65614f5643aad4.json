{"ast":null,"code":"import _slicedToArray from \"E:\\\\School Web Application\\\\FrontEnd\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport { unstable_debounce as debounce, unstable_ownerDocument as ownerDocument, unstable_useEnhancedEffect as useEnhancedEffect, unstable_ownerWindow as ownerWindow } from '@mui/utils';\nimport { useGridApiEventHandler, useGridApiOptionHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnsTotalWidthSelector } from '../columns';\nimport { gridDensityFactorSelector } from '../density';\nimport { useGridSelector } from '../../utils';\nimport { getVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { calculatePinnedRowsHeight } from '../rows/gridRowsUtils';\nimport { getTotalHeaderHeight } from '../columns/gridColumnsUtils';\nvar isTestEnvironment = process.env.NODE_ENV === 'test';\nvar hasScroll = function hasScroll(_ref) {\n  var content = _ref.content,\n    container = _ref.container,\n    scrollBarSize = _ref.scrollBarSize;\n  var hasScrollXIfNoYScrollBar = content.width > container.width;\n  var hasScrollYIfNoXScrollBar = content.height > container.height;\n  var hasScrollX = false;\n  var hasScrollY = false;\n  if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {\n    hasScrollX = hasScrollXIfNoYScrollBar;\n    hasScrollY = content.height + (hasScrollX ? scrollBarSize : 0) > container.height;\n\n    // We recalculate the scroll x to consider the size of the y scrollbar.\n    if (hasScrollY) {\n      hasScrollX = content.width + scrollBarSize > container.width;\n    }\n  }\n  return {\n    hasScrollX: hasScrollX,\n    hasScrollY: hasScrollY\n  };\n};\nexport function useGridDimensions(apiRef, props) {\n  var logger = useGridLogger(apiRef, 'useResizeContainer');\n  var errorShown = React.useRef(false);\n  var rootDimensionsRef = React.useRef(null);\n  var fullDimensionsRef = React.useRef(null);\n  var rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  var densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);\n  var rowHeight = Math.floor(props.rowHeight * densityFactor);\n  var totalHeaderHeight = getTotalHeaderHeight(apiRef, props.columnHeaderHeight);\n  var updateGridDimensionsRef = React.useCallback(function () {\n    var _apiRef$current$rootE;\n    var rootElement = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;\n    var columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);\n    var pinnedRowsHeight = calculatePinnedRowsHeight(apiRef);\n    if (!rootDimensionsRef.current) {\n      return;\n    }\n    var scrollBarSize;\n    if (props.scrollbarSize != null) {\n      scrollBarSize = props.scrollbarSize;\n    } else if (!columnsTotalWidth || !rootElement) {\n      scrollBarSize = 0;\n    } else {\n      var doc = ownerDocument(rootElement);\n      var scrollDiv = doc.createElement('div');\n      scrollDiv.style.width = '99px';\n      scrollDiv.style.height = '99px';\n      scrollDiv.style.position = 'absolute';\n      scrollDiv.style.overflow = 'scroll';\n      scrollDiv.className = 'scrollDiv';\n      rootElement.appendChild(scrollDiv);\n      scrollBarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n      rootElement.removeChild(scrollDiv);\n    }\n    var viewportOuterSize;\n    var hasScrollX;\n    var hasScrollY;\n    if (props.autoHeight) {\n      hasScrollY = false;\n      hasScrollX = Math.round(columnsTotalWidth) > rootDimensionsRef.current.width;\n      viewportOuterSize = {\n        width: rootDimensionsRef.current.width,\n        height: rowsMeta.currentPageTotalHeight + (hasScrollX ? scrollBarSize : 0)\n      };\n    } else {\n      viewportOuterSize = {\n        width: rootDimensionsRef.current.width,\n        height: rootDimensionsRef.current.height - totalHeaderHeight\n      };\n      var scrollInformation = hasScroll({\n        content: {\n          width: Math.round(columnsTotalWidth),\n          height: rowsMeta.currentPageTotalHeight\n        },\n        container: {\n          width: viewportOuterSize.width,\n          height: viewportOuterSize.height - pinnedRowsHeight.top - pinnedRowsHeight.bottom\n        },\n        scrollBarSize: scrollBarSize\n      });\n      hasScrollY = scrollInformation.hasScrollY;\n      hasScrollX = scrollInformation.hasScrollX;\n    }\n    var viewportInnerSize = {\n      width: viewportOuterSize.width - (hasScrollY ? scrollBarSize : 0),\n      height: viewportOuterSize.height - (hasScrollX ? scrollBarSize : 0)\n    };\n    var newFullDimensions = {\n      viewportOuterSize: viewportOuterSize,\n      viewportInnerSize: viewportInnerSize,\n      hasScrollX: hasScrollX,\n      hasScrollY: hasScrollY,\n      scrollBarSize: scrollBarSize\n    };\n    var prevDimensions = fullDimensionsRef.current;\n    fullDimensionsRef.current = newFullDimensions;\n    if (newFullDimensions.viewportInnerSize.width !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.width) || newFullDimensions.viewportInnerSize.height !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.height)) {\n      apiRef.current.publishEvent('viewportInnerSizeChange', newFullDimensions.viewportInnerSize);\n    }\n  }, [apiRef, props.scrollbarSize, props.autoHeight, rowsMeta.currentPageTotalHeight, totalHeaderHeight]);\n  var _React$useState = React.useState(),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    savedSize = _React$useState2[0],\n    setSavedSize = _React$useState2[1];\n  var debouncedSetSavedSize = React.useMemo(function () {\n    return debounce(setSavedSize, 60);\n  }, []);\n  var previousSize = React.useRef();\n  useEnhancedEffect(function () {\n    if (savedSize) {\n      updateGridDimensionsRef();\n      apiRef.current.publishEvent('debouncedResize', rootDimensionsRef.current);\n    }\n  }, [apiRef, savedSize, updateGridDimensionsRef]);\n\n  // This is the function called by apiRef.current.resize()\n  var resize = React.useCallback(function () {\n    apiRef.current.computeSizeAndPublishResizeEvent();\n  }, [apiRef]);\n  var getRootDimensions = React.useCallback(function () {\n    return fullDimensionsRef.current;\n  }, []);\n  var getViewportPageSize = React.useCallback(function () {\n    var dimensions = apiRef.current.getRootDimensions();\n    if (!dimensions) {\n      return 0;\n    }\n    var currentPage = getVisibleRows(apiRef, {\n      pagination: props.pagination,\n      paginationMode: props.paginationMode\n    });\n\n    // TODO: Use a combination of scrollTop, dimensions.viewportInnerSize.height and rowsMeta.possitions\n    // to find out the maximum number of rows that can fit in the visible part of the grid\n    if (props.getRowHeight) {\n      var renderContext = apiRef.current.getRenderContext();\n      var viewportPageSize = renderContext.lastRowIndex - renderContext.firstRowIndex;\n      return Math.min(viewportPageSize - 1, currentPage.rows.length);\n    }\n    var maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / rowHeight);\n    return Math.min(maximumPageSizeWithoutScrollBar, currentPage.rows.length);\n  }, [apiRef, props.pagination, props.paginationMode, props.getRowHeight, rowHeight]);\n  var computeSizeAndPublishResizeEvent = React.useCallback(function () {\n    var _apiRef$current$mainE, _previousSize$current, _previousSize$current2;\n    var mainEl = (_apiRef$current$mainE = apiRef.current.mainElementRef) == null ? void 0 : _apiRef$current$mainE.current;\n    if (!mainEl) {\n      return;\n    }\n    var win = ownerWindow(mainEl);\n    var computedStyle = win.getComputedStyle(mainEl);\n    var height = parseFloat(computedStyle.height) || 0;\n    var width = parseFloat(computedStyle.width) || 0;\n    var hasHeightChanged = height !== ((_previousSize$current = previousSize.current) == null ? void 0 : _previousSize$current.height);\n    var hasWidthChanged = width !== ((_previousSize$current2 = previousSize.current) == null ? void 0 : _previousSize$current2.width);\n    if (!previousSize.current || hasHeightChanged || hasWidthChanged) {\n      var size = {\n        width: width,\n        height: height\n      };\n      apiRef.current.publishEvent('resize', size);\n      previousSize.current = size;\n    }\n  }, [apiRef]);\n  var dimensionsApi = {\n    resize: resize,\n    getRootDimensions: getRootDimensions\n  };\n  var dimensionsPrivateApi = {\n    getViewportPageSize: getViewportPageSize,\n    updateGridDimensionsRef: updateGridDimensionsRef,\n    computeSizeAndPublishResizeEvent: computeSizeAndPublishResizeEvent\n  };\n  useGridApiMethod(apiRef, dimensionsApi, 'public');\n  useGridApiMethod(apiRef, dimensionsPrivateApi, 'private');\n  var isFirstSizing = React.useRef(true);\n  var handleResize = React.useCallback(function (size) {\n    rootDimensionsRef.current = size;\n\n    // jsdom has no layout capabilities\n    var isJSDOM = /jsdom/.test(window.navigator.userAgent);\n    if (size.height === 0 && !errorShown.current && !props.autoHeight && !isJSDOM) {\n      logger.error(['The parent DOM element of the data grid has an empty height.', 'Please make sure that this element has an intrinsic height.', 'The grid displays with a height of 0px.', '', 'More details: https://mui.com/r/x-data-grid-no-dimensions.'].join('\\n'));\n      errorShown.current = true;\n    }\n    if (size.width === 0 && !errorShown.current && !isJSDOM) {\n      logger.error(['The parent DOM element of the data grid has an empty width.', 'Please make sure that this element has an intrinsic width.', 'The grid displays with a width of 0px.', '', 'More details: https://mui.com/r/x-data-grid-no-dimensions.'].join('\\n'));\n      errorShown.current = true;\n    }\n    if (isTestEnvironment) {\n      // We don't need to debounce the resize for tests.\n      setSavedSize(size);\n      isFirstSizing.current = false;\n      return;\n    }\n    if (isFirstSizing.current) {\n      // We want to initialize the grid dimensions as soon as possible to avoid flickering\n      setSavedSize(size);\n      isFirstSizing.current = false;\n      return;\n    }\n    debouncedSetSavedSize(size);\n  }, [props.autoHeight, debouncedSetSavedSize, logger]);\n  useEnhancedEffect(function () {\n    return updateGridDimensionsRef();\n  }, [updateGridDimensionsRef]);\n  useGridApiOptionHandler(apiRef, 'sortedRowsSet', updateGridDimensionsRef);\n  useGridApiOptionHandler(apiRef, 'paginationModelChange', updateGridDimensionsRef);\n  useGridApiOptionHandler(apiRef, 'columnsChange', updateGridDimensionsRef);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  useGridApiOptionHandler(apiRef, 'debouncedResize', props.onResize);\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _slicedToArray from \"E:\\\\School Management System\\\\FrontEnd\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowsLookupSelector } from '../rows/gridRowsSelector';\nimport { gridRowSelectionStateSelector, selectedGridRowsSelector, selectedIdsLookupSelector } from './gridRowSelectionSelector';\nimport { gridPaginatedVisibleSortedGridRowIdsSelector } from '../pagination';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridExpandedSortedRowIdsSelector } from '../filter/gridFilterSelector';\nimport { GRID_CHECKBOX_SELECTION_COL_DEF, GRID_ACTIONS_COLUMN_TYPE } from '../../../colDef';\nimport { GridCellModes } from '../../../models/gridEditRowModel';\nimport { isKeyboardEvent, isNavigationKey } from '../../../utils/keyboardUtils';\nimport { getVisibleRows, useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from '../../../constants/gridDetailPanelToggleField';\nimport { gridClasses } from '../../../constants/gridClasses';\nvar getSelectionModelPropValue = function getSelectionModelPropValue(selectionModelProp, prevSelectionModel) {\n  if (selectionModelProp == null) {\n    return selectionModelProp;\n  }\n  if (Array.isArray(selectionModelProp)) {\n    return selectionModelProp;\n  }\n  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {\n    return prevSelectionModel;\n  }\n  return [selectionModelProp];\n};\nexport var rowSelectionStateInitializer = function rowSelectionStateInitializer(state, props) {\n  var _getSelectionModelPro;\n  return _extends({}, state, {\n    rowSelection: props.rowSelection ? (_getSelectionModelPro = getSelectionModelPropValue(props.rowSelectionModel)) != null ? _getSelectionModelPro : [] : []\n  });\n};\n\n/**\n * @requires useGridRows (state, method) - can be after\n * @requires useGridParamsApi (method) - can be after\n * @requires useGridFocus (state) - can be after\n * @requires useGridKeyboardNavigation (`cellKeyDown` event must first be consumed by it)\n */\nexport var useGridRowSelection = function useGridRowSelection(apiRef, props) {\n  var logger = useGridLogger(apiRef, 'useGridSelection');\n  var runIfRowSelectionIsEnabled = function runIfRowSelectionIsEnabled(callback) {\n    return function () {\n      if (props.rowSelection) {\n        callback.apply(void 0, arguments);\n      }\n    };\n  };\n  var propRowSelectionModel = React.useMemo(function () {\n    return getSelectionModelPropValue(props.rowSelectionModel, gridRowSelectionStateSelector(apiRef.current.state));\n  }, [apiRef, props.rowSelectionModel]);\n  var lastRowToggled = React.useRef(null);\n  apiRef.current.registerControlState({\n    stateId: 'rowSelection',\n    propModel: propRowSelectionModel,\n    propOnChange: props.onRowSelectionModelChange,\n    stateSelector: gridRowSelectionStateSelector,\n    changeEvent: 'rowSelectionChange'\n  });\n  var checkboxSelection = props.checkboxSelection,\n    disableMultipleRowSelection = props.disableMultipleRowSelection,\n    disableRowSelectionOnClick = props.disableRowSelectionOnClick,\n    pagination = props.pagination,\n    paginationMode = props.paginationMode,\n    propIsRowSelectable = props.isRowSelectable;\n  var canHaveMultipleSelection = !disableMultipleRowSelection || checkboxSelection;\n  var visibleRows = useGridVisibleRows(apiRef, props);\n  var expandMouseRowRangeSelection = React.useCallback(function (id) {\n    var _lastRowToggled$curre;\n    var endId = id;\n    var startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;\n    var isSelected = apiRef.current.isRowSelected(id);\n    if (isSelected) {\n      var visibleRowIds = gridExpandedSortedRowIdsSelector(apiRef);\n      var startIndex = visibleRowIds.findIndex(function (rowId) {\n        return rowId === startId;\n      });\n      var endIndex = visibleRowIds.findIndex(function (rowId) {\n        return rowId === endId;\n      });\n      if (startIndex === endIndex) {\n        return;\n      }\n      if (startIndex > endIndex) {\n        endId = visibleRowIds[endIndex + 1];\n      } else {\n        endId = visibleRowIds[endIndex - 1];\n      }\n    }\n    lastRowToggled.current = id;\n    apiRef.current.selectRowRange({\n      startId: startId,\n      endId: endId\n    }, !isSelected);\n  }, [apiRef]);\n\n  /**\n   * API METHODS\n   */\n  var setRowSelectionModel = React.useCallback(function (model) {\n    if (props.signature === GridSignature.DataGrid && !props.checkboxSelection && Array.isArray(model) && model.length > 1) {\n      throw new Error(['MUI: `rowSelectionModel` can only contain 1 item in DataGrid.', 'You need to upgrade to DataGridPro or DataGridPremium component to unlock multiple selection.'].join('\\n'));\n    }\n    var currentModel = gridRowSelectionStateSelector(apiRef.current.state);\n    if (currentModel !== model) {\n      logger.debug(\"Setting selection model\");\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          rowSelection: props.rowSelection ? model : []\n        });\n      });\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, logger, props.rowSelection, props.signature, props.checkboxSelection]);\n  var isRowSelected = React.useCallback(function (id) {\n    return gridRowSelectionStateSelector(apiRef.current.state).includes(id);\n  }, [apiRef]);\n  var isRowSelectable = React.useCallback(function (id) {\n    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id))) {\n      return false;\n    }\n    var rowNode = apiRef.current.getRowNode(id);\n    if ((rowNode == null ? void 0 : rowNode.type) === 'footer' || (rowNode == null ? void 0 : rowNode.type) === 'pinnedRow') {\n      return false;\n    }\n    return true;\n  }, [apiRef, propIsRowSelectable]);\n  var getSelectedRows = React.useCallback(function () {\n    return selectedGridRowsSelector(apiRef);\n  }, [apiRef]);\n  var selectRow = React.useCallback(function (id) {\n    var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!apiRef.current.isRowSelectable(id)) {\n      return;\n    }\n    lastRowToggled.current = id;\n    if (resetSelection) {\n      logger.debug(\"Setting selection for row \".concat(id));\n      apiRef.current.setRowSelectionModel(isSelected ? [id] : []);\n    } else {\n      logger.debug(\"Toggling selection for row \".concat(id));\n      var selection = gridRowSelectionStateSelector(apiRef.current.state);\n      var newSelection = selection.filter(function (el) {\n        return el !== id;\n      });\n      if (isSelected) {\n        newSelection.push(id);\n      }\n      var isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n      if (isSelectionValid) {\n        apiRef.current.setRowSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  var selectRows = React.useCallback(function (ids) {\n    var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    logger.debug(\"Setting selection for several rows\");\n    var selectableIds = ids.filter(function (id) {\n      return apiRef.current.isRowSelectable(id);\n    });\n    var newSelection;\n    if (resetSelection) {\n      newSelection = isSelected ? selectableIds : [];\n    } else {\n      // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n      var selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n      selectableIds.forEach(function (id) {\n        if (isSelected) {\n          selectionLookup[id] = id;\n        } else {\n          delete selectionLookup[id];\n        }\n      });\n      newSelection = Object.values(selectionLookup);\n    }\n    var isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n    if (isSelectionValid) {\n      apiRef.current.setRowSelectionModel(newSelection);\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  var selectRowRange = React.useCallback(function (_ref) {\n    var startId = _ref.startId,\n      endId = _ref.endId;\n    var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {\n      return;\n    }\n    logger.debug(\"Expanding selection from row \".concat(startId, \" to row \").concat(endId));\n\n    // Using rows from all pages allow to select a range across several pages\n    var allPagesRowIds = gridExpandedSortedRowIdsSelector(apiRef);\n    var startIndex = allPagesRowIds.indexOf(startId);\n    var endIndex = allPagesRowIds.indexOf(endId);\n    var _ref2 = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex],\n      _ref3 = _slicedToArray(_ref2, 2),\n      start = _ref3[0],\n      end = _ref3[1];\n    var rowsBetweenStartAndEnd = allPagesRowIds.slice(start, end + 1);\n    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);\n  }, [apiRef, logger]);\n  var selectionPublicApi = {\n    selectRow: selectRow,\n    setRowSelectionModel: setRowSelectionModel,\n    getSelectedRows: getSelectedRows,\n    isRowSelected: isRowSelected,\n    isRowSelectable: isRowSelectable\n  };\n  var selectionPrivateApi = {\n    selectRows: selectRows,\n    selectRowRange: selectRowRange\n  };\n  useGridApiMethod(apiRef, selectionPublicApi, 'public');\n  useGridApiMethod(apiRef, selectionPrivateApi, props.signature === GridSignature.DataGrid ? 'private' : 'public');\n\n  /**\n   * EVENTS\n   */\n  var removeOutdatedSelection = React.useCallback(function () {\n    if (props.keepNonExistentRowsSelected) {\n      return;\n    }\n    var currentSelection = gridRowSelectionStateSelector(apiRef.current.state);\n    var rowsLookup = gridRowsLookupSelector(apiRef);\n\n    // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n    var selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n    var hasChanged = false;\n    currentSelection.forEach(function (id) {\n      if (!rowsLookup[id]) {\n        delete selectionLookup[id];\n        hasChanged = true;\n      }\n    });\n    if (hasChanged) {\n      apiRef.current.setRowSelectionModel(Object.values(selectionLookup));\n    }\n  }, [apiRef, props.keepNonExistentRowsSelected]);\n  var handleSingleRowSelection = React.useCallback(function (id, event) {\n    var hasCtrlKey = event.metaKey || event.ctrlKey;\n\n    // multiple selection is only allowed if:\n    // - it is a checkboxSelection\n    // - it is a keyboard selection\n    // - Ctrl is pressed\n\n    var isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);\n    var resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;\n    var isSelected = apiRef.current.isRowSelected(id);\n    if (resetSelection) {\n      apiRef.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);\n    } else {\n      apiRef.current.selectRow(id, !isSelected, false);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);\n  var handleRowClick = React.useCallback(function (params, event) {\n    var _closest;\n    if (disableRowSelectionOnClick) {\n      return;\n    }\n    var field = (_closest = event.target.closest(\".\".concat(gridClasses.cell))) == null ? void 0 : _closest.getAttribute('data-field');\n    if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {\n      // click on checkbox should not trigger row selection\n      return;\n    }\n    if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {\n      // click to open the detail panel should not select the row\n      return;\n    }\n    if (field) {\n      var column = apiRef.current.getColumn(field);\n      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {\n        return;\n      }\n    }\n    var rowNode = apiRef.current.getRowNode(params.id);\n    if (rowNode.type === 'pinnedRow') {\n      return;\n    }\n    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      handleSingleRowSelection(params.id, event);\n    }\n  }, [disableRowSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);\n  var preventSelectionOnShift = React.useCallback(function (params, event) {\n    if (canHaveMultipleSelection && event.shiftKey) {\n      var _window$getSelection;\n      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();\n    }\n  }, [canHaveMultipleSelection]);\n  var handleRowSelectionCheckboxChange = React.useCallback(function (params, event) {\n    if (event.nativeEvent.shiftKey) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      apiRef.current.selectRow(params.id, params.value);\n    }\n  }, [apiRef, expandMouseRowRangeSelection]);\n  var handleHeaderSelectionCheckboxChange = React.useCallback(function (params) {\n    var shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;\n    var rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridExpandedSortedRowIdsSelector(apiRef);\n    apiRef.current.selectRows(rowsToBeSelected, params.value);\n  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);\n  var handleCellKeyDown = React.useCallback(function (params, event) {\n    // Get the most recent cell mode because it may have been changed by another listener\n    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {\n      return;\n    }\n\n    // Ignore portal\n    // Do not apply shortcuts if the focus is not on the cell root component\n    if (!event.currentTarget.contains(event.target)) {\n      return;\n    }\n    if (isNavigationKey(event.key) && event.shiftKey) {\n      // The cell that has focus after the keyboard navigation\n      var focusCell = gridFocusCellSelector(apiRef);\n      if (focusCell && focusCell.id !== params.id) {\n        event.preventDefault();\n        var isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);\n        if (!canHaveMultipleSelection) {\n          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);\n          return;\n        }\n        var newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);\n        var previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);\n        var start;\n        var end;\n        if (newRowIndex > previousRowIndex) {\n          if (isNextRowSelected) {\n            // We are navigating to the bottom of the page and adding selected rows\n            start = previousRowIndex;\n            end = newRowIndex - 1;\n          } else {\n            // We are navigating to the bottom of the page and removing selected rows\n            start = previousRowIndex;\n            end = newRowIndex;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isNextRowSelected) {\n            // We are navigating to the top of the page and removing selected rows\n            start = newRowIndex + 1;\n            end = previousRowIndex;\n          } else {\n            // We are navigating to the top of the page and adding selected rows\n            start = newRowIndex;\n            end = previousRowIndex;\n          }\n        }\n        var rowsBetweenStartAndEnd = visibleRows.rows.slice(start, end + 1).map(function (row) {\n          return row.id;\n        });\n        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);\n        return;\n      }\n    }\n    if (event.key === ' ' && event.shiftKey) {\n      event.preventDefault();\n      handleSingleRowSelection(params.id, event);\n      return;\n    }\n    if (event.key === 'a' && (event.ctrlKey || event.metaKey)) {\n      event.preventDefault();\n      selectRows(apiRef.current.getAllRowIds(), true);\n    }\n  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', runIfRowSelectionIsEnabled(removeOutdatedSelection));\n  useGridApiEventHandler(apiRef, 'rowClick', runIfRowSelectionIsEnabled(handleRowClick));\n  useGridApiEventHandler(apiRef, 'rowSelectionCheckboxChange', runIfRowSelectionIsEnabled(handleRowSelectionCheckboxChange));\n  useGridApiEventHandler(apiRef, 'headerSelectionCheckboxChange', handleHeaderSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'cellMouseDown', runIfRowSelectionIsEnabled(preventSelectionOnShift));\n  useGridApiEventHandler(apiRef, 'cellKeyDown', runIfRowSelectionIsEnabled(handleCellKeyDown));\n\n  /**\n   * EFFECTS\n   */\n  React.useEffect(function () {\n    if (propRowSelectionModel !== undefined) {\n      apiRef.current.setRowSelectionModel(propRowSelectionModel);\n    }\n  }, [apiRef, propRowSelectionModel, props.rowSelection]);\n  React.useEffect(function () {\n    if (!props.rowSelection) {\n      apiRef.current.setRowSelectionModel([]);\n    }\n  }, [apiRef, props.rowSelection]);\n  var isStateControlled = propRowSelectionModel != null;\n  React.useEffect(function () {\n    if (isStateControlled || !props.rowSelection) {\n      return;\n    }\n\n    // props.isRowSelectable changed\n    var currentSelection = gridRowSelectionStateSelector(apiRef.current.state);\n    if (isRowSelectable) {\n      var newSelection = currentSelection.filter(function (id) {\n        return isRowSelectable(id);\n      });\n      if (newSelection.length < currentSelection.length) {\n        apiRef.current.setRowSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, isRowSelectable, isStateControlled, props.rowSelection]);\n  React.useEffect(function () {\n    if (!props.rowSelection) {\n      return;\n    }\n    var currentSelection = gridRowSelectionStateSelector(apiRef.current.state);\n    if (!canHaveMultipleSelection && currentSelection.length > 1) {\n      var _getVisibleRows = getVisibleRows(apiRef, {\n          pagination: pagination,\n          paginationMode: paginationMode\n        }),\n        currentPageRows = _getVisibleRows.rows;\n      var currentPageRowsLookup = currentPageRows.reduce(function (acc, _ref4) {\n        var id = _ref4.id;\n        acc[id] = true;\n        return acc;\n      }, {});\n      var firstSelectableRow = currentSelection.find(function (id) {\n        var isSelectable = true;\n        if (isRowSelectable) {\n          isSelectable = isRowSelectable(id);\n        }\n        return isSelectable && currentPageRowsLookup[id]; // Check if the row is in the current page\n      });\n\n      apiRef.current.setRowSelectionModel(firstSelectableRow !== undefined ? [firstSelectableRow] : []);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleRowSelection, isRowSelectable, pagination, paginationMode, props.rowSelection]);\n};","map":null,"metadata":{},"sourceType":"module"}